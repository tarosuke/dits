## チケットの親子関係と種類

子チケットを持つチケットをノードチケット、子チケットを持たないチケットをリーフチケットと呼ぶ。

## チケットの状態

* New
新規。
* Opened
執行中。
* Closed(finished)
終了
* Deleted
削除

## ditsコマンド

コミットメッセージの最初の行が.ditsで始まっていたらditsコマンド。それ以外はコメントであるとして扱われる。

### 操作

最後のものが現在の状態となる。

* .dits open (*担当者*)
チケットをopenにする。担当者はメールアドレス。かつデフォルトは自分(gitで設定されているアドレス)。最後が有効。チケットがdelete、closeされていた場合再open。
ブランチを取得するときはこのコマンドで終了。
操作は以下の通り。
    1. ブランチ作成、移動
    2. 担当者を```git config --get user.email```で取得してコマンドをcommit
* 子チケット操作、認識
    * .dits new *子チケットのタイトル*
    子チケットを作成。このメッセージのcommit自体のハッシュが子チケットのID。現れた全てが有効。
    * .dits close *子チケット*
    子チケットをcloseする。最後が有効。一般的にはマージ後。
    * .dits delete *子チケット*
    子チケットをdeleteする。最後が有効。

## チケットID(TID)

子チケットをnewしたcommitのハッシュがチケットIDとして使われる。

おい、そこのお前、**クソ長いGitのハッシュを口頭で**伝える進捗報告会なんてしようと思うなよ？そういうのはチケット上でやれ。

# 標準ワークフロー

dits設計時にモデルとしているワークフローを説明する。

ditsは分散ITSであると同時に多階層ITSでもあるのでプロジェクト全体からイテレーション、ToDoレベルまでをカバーする。WBSと呼ばれることが多い上位の階層は分掌に対応させるのが良いだろう。

### プロジェクトの準備

新たにリポジトリを用意するか、既存のリポジトリにプロジェクト用のissueを作る。前者は各プロジェクトが独立している場合に向いていて、後者はシリーズ展開などで共通のデータやコードが多い場合に向いている。

なお、後者の運用ポリシーだと大量の無駄なデータを取得しがちなのでclone時に--no--treeを指定して必要なデータのみ取得するようにしておくことをおすすめする。これはditsがリポジトリをcloneする時の動作でもある(予定)。

### スケジューリング